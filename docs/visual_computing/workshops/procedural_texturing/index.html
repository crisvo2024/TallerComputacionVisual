<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Procedural texturing #  En este taller se estudió la técnica denominada procedurtal texturing con la cual se busca generar programáticamente texturas en el shader para mapearlas a figuras
1. Introducción #  Para este taller quisimos explorar las diferentes posibilidades que tenía el procedural texturing. Esta técnica para generar texturas en el shader es muy útil dado que es muy eficiente al aprovechar las capacidades de las GPU y permite una mayor flexibilidad al momento de generar escenarios en 3D."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Procedural texturing #  En este taller se estudió la técnica denominada procedurtal texturing con la cual se busca generar programáticamente texturas en el shader para mapearlas a figuras
1. Introducción #  Para este taller quisimos explorar las diferentes posibilidades que tenía el procedural texturing. Esta técnica para generar texturas en el shader es muy útil dado que es muy eficiente al aprovechar las capacidades de las GPU y permite una mayor flexibilidad al momento de generar escenarios en 3D."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/showcase/docs/visual_computing/workshops/procedural_texturing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-27T16:53:25-05:00"><title>Procedural Texturing | Visual Computing</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.ab46de3e725a6415339a37bba23a0067534a37289b063c9f8d011515a63097a8.css integrity="sha256-q0bePnJaZBUzmje7ojoAZ1NKNyibBjyfjQEVFaYwl6g=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.debc307447a5e504d7f46b7af7606395f66889384ba41eee1d8e7cf46aea7be0.js integrity="sha256-3rwwdEel5QTX9Gt692BjlfZoiThLpB7uHY589Grqe+A=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Visual Computing</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Visual Computing</span><ul><li><a href=/showcase/docs/visual_computing/logs/>Logs</a></li><li><a href=/showcase/docs/visual_computing/profiles/>Profiles</a></li><li><input type=checkbox id=section-29bdbf19413e05c2e701868288e4ab17 class=toggle>
<label for=section-29bdbf19413e05c2e701868288e4ab17 class="flex justify-between"><a href=/showcase/docs/visual_computing/template_examples/>Template Examples</a></label><ul><li><a href=/showcase/docs/visual_computing/template_examples/buttons/>Buttons</a></li><li><a href=/showcase/docs/visual_computing/template_examples/columns/>Columns</a></li><li><a href=/showcase/docs/visual_computing/template_examples/details/>Details</a></li><li><a href=/showcase/docs/visual_computing/template_examples/expand/>Expand</a></li><li><a href=/showcase/docs/visual_computing/template_examples/hints/>Hints</a></li><li><a href=/showcase/docs/visual_computing/template_examples/katex/>Katex</a></li><li><a href=/showcase/docs/visual_computing/template_examples/mermaid/>Mermaid</a></li><li><input type=checkbox id=section-619959e653037cbeb27c2fc2f70843f1 class=toggle>
<label for=section-619959e653037cbeb27c2fc2f70843f1 class="flex justify-between"><a href=/showcase/docs/visual_computing/template_examples/p5/>P5</a></label><ul><li><a href=/showcase/docs/visual_computing/template_examples/p5/div/>Div</a></li><li><a href=/showcase/docs/visual_computing/template_examples/p5/iframe/>Iframe</a></li></ul></li><li><a href=/showcase/docs/visual_computing/template_examples/tabs/>Tabs</a></li></ul></li><li><input type=checkbox id=section-43decbbd35cace6c4f05150232266586 class=toggle checked>
<label for=section-43decbbd35cace6c4f05150232266586 class="flex justify-between"><a href=/showcase/docs/visual_computing/workshops/>Workshops</a></label><ul><li><a href=/showcase/docs/visual_computing/workshops/anti_aliasing/>Anti Aliasing</a></li><li><a href=/showcase/docs/visual_computing/workshops/illutions/>Illutions</a></li><li><a href=/showcase/docs/visual_computing/workshops/image_processing/>Image Processing</a></li><li><a href=/showcase/docs/visual_computing/workshops/main_spaces/>Main Spaces</a></li><li><a href=/showcase/docs/visual_computing/workshops/procedural_texturing/ class=active>Procedural Texturing</a></li></ul></li></ul></li></ul><ul><li><a href=/showcase/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Procedural Texturing</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#procedural-texturing><strong>Procedural texturing</strong></a><ul><li><ul><li><a href=#1-introducción><strong>1. Introducción</strong></a></li><li><a href=#2-revisión-bibliográfica><strong>2. Revisión bibliográfica</strong></a></li><li><a href=#3-métodos><strong>3. Métodos</strong></a></li><li><a href=#4-resultados><strong>4. Resultados</strong></a></li><li><a href=#5-discusión><strong>5. Discusión</strong></a></li><li><a href=#6-conclusión><strong>6. Conclusión</strong></a></li><li><a href=#7-referencias><strong>7. Referencias</strong></a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=procedural-texturing><strong>Procedural texturing</strong>
<a class=anchor href=#procedural-texturing>#</a></h1><p>En este taller se estudió la técnica denominada <strong>procedurtal texturing</strong> con la cual se busca generar programáticamente texturas en el shader para mapearlas a figuras</p><h3 id=1-introducción><strong>1. Introducción</strong>
<a class=anchor href=#1-introducci%c3%b3n>#</a></h3><p>Para este taller quisimos explorar las diferentes posibilidades que tenía el procedural texturing. Esta técnica para generar texturas en el shader es muy útil dado que es muy eficiente al aprovechar las capacidades de las GPU y permite una mayor flexibilidad al momento de generar escenarios en 3D. Pero al ser generadas por computador, se hace necesario el uso de funciones de ruido, estas funciones de ruido permiten generar la sensación de aleatoriedad, como la que se genera en la naturaleza de los materiales rugosos, permitiendo así la generación de texturas mucho más realistas. Adicionalmente, estas texturas necesitan de diseños que permitan percibir profundidad entre otros rasgos para no verse solo como una imagen pintada en el objeto, para lo cual ya se utilizan modelos de iluminación y de texture mapping combinados con las técnicas de procedural texturing.</p><h3 id=2-revisión-bibliográfica><strong>2. Revisión bibliográfica</strong>
<a class=anchor href=#2-revisi%c3%b3n-bibliogr%c3%a1fica>#</a></h3><p>Para empezar con la generación de texturas se realizó una revisión bibliográfica en cuanto a generación de patrones en el shader, posteriormente se exploró la parte de aleatorización de las texturas y finalmente se intentó realizar una revisión de modelos de iluminación.</p><h4 id=21-patrones><strong>2.1 Patrones</strong>
<a class=anchor href=#21-patrones>#</a></h4><p>Dado que los programas en los shaders siempre se realizan pixel por pixel, sin importar cuánto se repita una forma, el número de cálculos se mantiene constante, esto hace que los shaders sean el lugar ideal para generar patrones.</p><p>Para la generación de patrones, se utiliza comúnmente una normalización del espacio, de forma que las coordenadas queden entre 1 y 0, las cuales se pueden dividir fácilmente para generar una cuadrícula, que sea un marco para la generación de los patrones. Las cuadrículas son especialmente útiles a la hora de generar patrones y se han utilizado desde la antigüedad, un ejemplo de esto son los mosaicos en los baños romanos.</p><p>En glsl para realizar este proceso se toman las coordenadas de textura y se dividen en la resolución de la pantalla, posteriormente se multiplican estas coordenadas por el tamaño de la cuadrícula que se requiera, de esta forma se pueden utilizar funciones como fract que retorna la parte no entera de un número o mod que saca el módulo de un número en otro número, para empezar a dividir la cuadrícula y generar las formas necesarias. Un ejemplo de esto es el siguiente shader:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>// Author @patriciogv - 2015</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> u_resolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> u_time;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> circle(<span style=color:#66d9ef>in</span> <span style=color:#66d9ef>vec2</span> _st, <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>float</span> _radius){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> l <span style=color:#f92672>=</span> _st<span style=color:#f92672>-</span><span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.</span><span style=color:#f92672>-</span>smoothstep(_radius<span style=color:#f92672>-</span>(_radius<span style=color:#f92672>*</span><span style=color:#ae81ff>0.01</span>),
</span></span><span style=display:flex><span>                         _radius<span style=color:#f92672>+</span>(_radius<span style=color:#f92672>*</span><span style=color:#ae81ff>0.01</span>),
</span></span><span style=display:flex><span>                         dot(l,l)<span style=color:#f92672>*</span><span style=color:#ae81ff>4.0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>vec2</span> st <span style=color:#f92672>=</span> gl_FragCoord.xy<span style=color:#f92672>/</span>u_resolution;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> color <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>3.0</span>;      <span style=color:#75715e>// Scale up the space by 3</span>
</span></span><span style=display:flex><span>    st <span style=color:#f92672>=</span> fract(st); <span style=color:#75715e>// Wrap around 1.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Now we have 9 spaces that go from 0-1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    color <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(st,<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	gl_FragColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(color,<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>que genera la siguiente textura:</p><p><img src=/showcase/sketches/cuadricula.png alt="Textura generada" title="Textura generada"></p><p>Dentro de estas cuadrículas ya podemos empezar a generar nuestros patrones. Uno de estos son los patrones de Offset o de desplazamiento. Para poder generar estos patrones, que son como los de una pared de ladrillos, se hace necesario el identificar si una fila es par o impar para saber si el ladrillo se debe desplazar o no.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span>y <span style=color:#f92672>=</span> step(<span style=color:#ae81ff>1.0</span>,mod(x,<span style=color:#ae81ff>2.0</span>));
</span></span></code></pre></div><p>Esta es la forma más eficiente de realizar lo anterior en el shader. Esta línea lo que hace es que aplica el módulo en base 2 para x, de esta forma toma dos cuadros de la cuadrícula generada, y con la función step, diferencia entre estas 2 cual es la par y cual es la impar generando un 0 para cualquier valor menor que 1 y un 1 para todo lo que sea mayor que 1. Se puede notar cómo esto podría realizarse con un condicional y un &lt; pero, al ser step una función del lenguaje, funciona mucho más rápido que este condicional. Es por esto que cada vez que se pueda usar una función como esta, va a ser más óptimo usarla.</p><h4 id=22-ruido><strong>2.2 Ruido</strong>
<a class=anchor href=#22-ruido>#</a></h4><p>Ya teniendo las bases para generar formas definidas, se hace necesario introducir la aleatoriedad para generar formas más realistas. El primer acercamiento que se hace frente a este tema, utiliza funciones sinusoidales, las multiplica por números muy grandes y extrae la parte fraccionaria de cada número, generando números pseudo-aleatorios. Es necesario notar que como generadoras de números pseudo-aleatorios, estas funciones reciben un número y a partir de este generan el número &ldquo;aleatorio&rdquo;, sin embargo, ante un mismo número siempre se va a generar la misma salida. Adicionalmente, esta forma de generar números, tiene un problema y es que los números tienden a concentrarse en el centro. Una función que podría utilizarse para generar ruido en 2D es la siguiente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span>    fract(sin(dot(st.xy, <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>12.9898</span>,<span style=color:#ae81ff>78.233</span>))) <span style=color:#f92672>*</span> <span style=color:#ae81ff>43758.5453123</span>);
</span></span></code></pre></div><p>Esta función utiliza el seno del producto punto del vector de coordenadas y un vector aleatorio, multiplicado por un valor igualmente aleatorio y finalmente toma la parte fraccionaria de este número. El resultado de esta función es un ruido como el que se generaba en los televisores antiguos cuando no había señal.</p><p><img src=/showcase/sketches/tv.png alt=TV title=TV></p><p>Aunque esta fórmula aporta aleatoriedad, esta no es ni parecida a la que encontramos normalmente en la naturaleza y los objetos reales, esto se da porque esté aleatorio no guarda ninguna correlación entre sus valores, pero en la naturaleza, la mayoría de los patrones guardan memoria del estado anterior.</p><p>El lograr un ruido más natural, fue el reto al que se enfrentó Ken Perlin en los 80s cuando se enfrentó al reto de generar texturas más realistas para su película Tron. Como resultado ideó dos algoritmos, uno de ellos ganador de un Oscar.</p><p>El primer algoritmo llamado “Value Noise”, utiliza una interpolación de la parte entera y la parte fraccionaria del número de entrada para realizar la generación, de esta forma se mantiene la correlación con la parte entera, pero también una parte aleatoria con la no entera. El algoritmo resultante es este:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span>    <span style=color:#66d9ef>float</span> i <span style=color:#f92672>=</span> floor(x);  <span style=color:#75715e>// integer</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> f <span style=color:#f92672>=</span> fract(x);  <span style=color:#75715e>// fraction</span>
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> mix(rand(i), rand(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>), smoothstep(<span style=color:#ae81ff>0.</span>,<span style=color:#ae81ff>1.</span>,f));
</span></span></code></pre></div><p>La función smoothstep nos permite que esta interpolación no sea lineal sino que como lo dice su nombre sea suavizada, ayudando a que la conexión de los valores se vea mucho más natural. Esto también se puede realizar utilizando una fórmula cúbica personalizada como prefieren algunos autores.</p><p>No obstante, esta función no fue lo suficientemente buena para Perlin, quien en 1985 ideó otra implementación de este algoritmo, la cual llamó &ldquo;Gradient Noise&rdquo;. En esta, Perlin averiguar cómo interpolar gradientes aleatorios en vez de valores. Estos gradientes son el resultado de una función aleatoria en 2D que retorna direcciónes en vez de valores simples. El resultado:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> i <span style=color:#f92672>=</span> floor(st);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> f <span style=color:#f92672>=</span> fract(st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> u <span style=color:#f92672>=</span> f<span style=color:#f92672>*</span>f<span style=color:#f92672>*</span>(<span style=color:#ae81ff>3.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span><span style=color:#f92672>*</span>f);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mix( mix( dot( random2(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>0.0</span>) ), f <span style=color:#f92672>-</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>0.0</span>) ),
</span></span><span style=display:flex><span>                     dot( random2(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>0.0</span>) ), f <span style=color:#f92672>-</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>0.0</span>) ), u.x),
</span></span><span style=display:flex><span>                mix( dot( random2(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>1.0</span>) ), f <span style=color:#f92672>-</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>1.0</span>) ),
</span></span><span style=display:flex><span>                     dot( random2(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>1.0</span>) ), f <span style=color:#f92672>-</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>1.0</span>) ), u.x), u.y);
</span></span></code></pre></div><p>Como podemos notar en este caso se utilizó una función cúbica personalizada en vez de smoothstep, para calcular u.</p><p>Pero para Perlin esto todavía no fue suficiente, el sabia que podía hacerlo mejor, por lo que en 2001 presentó el &ldquo;simplex noise&rdquo;. Este mejoraba el algoritmo anterior en los siguientes aspectos:</p><ul><li>Un algoritmo con menor complejidad computacional y menos multiplicaciones.</li><li>Un ruido que escala a dimensiones más altas con menos coste computacional.</li><li>Un ruido sin artefactos direccionales.</li><li>Un ruido con gradientes bien definidos y continuos que puedan calcularse de forma bastante económica.</li><li>Un algoritmo fácil de implementar en hardware.</li></ul><p>Para la mejora, el vio que en dos dimensiones el estaba interpolando 4 puntos del cuadrado, así que él pudo notar que para 3 y 4 dimensiones se tenían que interpolar 6 y 16 puntos, de esta forma para N dimensiones 2^n. Por lo que decidió reemplazar la cuadrícula, por un una rejilla simplex de triángulos equiláteros
La forma simplex para N dimesiones es una forma de N+1 esquinas, en otras palabras 1 esquina menos en 2 dimensiones, 4 en 3D y 11en 4D.</p><p>¿Cómo se hace la rejilla simplex? la cuadrícula simplex puede obtenerse subdividiendo las celdas de una cuadrícula regular de 4 esquinas en dos triángulos isósceles y luego distprcionandola hasta que cada triángulo sea equilátero.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> u_resolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> u_mouse;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> u_time;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Some useful functions</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>vec3</span> mod289(<span style=color:#66d9ef>vec3</span> x) { <span style=color:#66d9ef>return</span> x <span style=color:#f92672>-</span> floor(x <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>289.0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>289.0</span>; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>vec2</span> mod289(<span style=color:#66d9ef>vec2</span> x) { <span style=color:#66d9ef>return</span> x <span style=color:#f92672>-</span> floor(x <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>289.0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>289.0</span>; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>vec3</span> permute(<span style=color:#66d9ef>vec3</span> x) { <span style=color:#66d9ef>return</span> mod289(((x<span style=color:#f92672>*</span><span style=color:#ae81ff>34.0</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0</span>)<span style=color:#f92672>*</span>x); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Description : GLSL 2D simplex noise function</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//      Author : Ian McEwan, Ashima Arts</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  Maintainer : ijm</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//     Lastmod : 20110822 (ijm)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//     License :</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  Copyright (C) 2011 Ashima Arts. All rights reserved.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  Distributed under the MIT License. See LICENSE file.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  https://github.com/ashima/webgl-noise</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> snoise(<span style=color:#66d9ef>vec2</span> v) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Precompute values for skewed triangular grid</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>vec4</span> C <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(<span style=color:#ae81ff>0.211324865405187</span>,
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// (3.0-sqrt(3.0))/6.0</span>
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0.366025403784439</span>,
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 0.5*(sqrt(3.0)-1.0)</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>-</span><span style=color:#ae81ff>0.577350269189626</span>,
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// -1.0 + 2.0 * C.x</span>
</span></span><span style=display:flex><span>                        <span style=color:#ae81ff>0.024390243902439</span>);
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 1.0 / 41.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First corner (x0)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> i  <span style=color:#f92672>=</span> floor(v <span style=color:#f92672>+</span> dot(v, C.yy));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> x0 <span style=color:#f92672>=</span> v <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> dot(i, C.xx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Other two corners (x1, x2)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> i1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>    i1 <span style=color:#f92672>=</span> (x0.x <span style=color:#f92672>&gt;</span> x0.y)<span style=color:#f92672>?</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>)<span style=color:#f92672>:</span><span style=color:#66d9ef>vec2</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> x1 <span style=color:#f92672>=</span> x0.xy <span style=color:#f92672>+</span> C.xx <span style=color:#f92672>-</span> i1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> x2 <span style=color:#f92672>=</span> x0.xy <span style=color:#f92672>+</span> C.zz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Do some permutations to avoid</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// truncation effects in permutation</span>
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> mod289(i);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> p <span style=color:#f92672>=</span> permute(
</span></span><span style=display:flex><span>            permute( i.y <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec3</span>(<span style=color:#ae81ff>0.0</span>, i1.y, <span style=color:#ae81ff>1.0</span>))
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> i.x <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec3</span>(<span style=color:#ae81ff>0.0</span>, i1.x, <span style=color:#ae81ff>1.0</span> ));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> m <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.5</span> <span style=color:#f92672>-</span> <span style=color:#66d9ef>vec3</span>(
</span></span><span style=display:flex><span>                        dot(x0,x0),
</span></span><span style=display:flex><span>                        dot(x1,x1),
</span></span><span style=display:flex><span>                        dot(x2,x2)
</span></span><span style=display:flex><span>                        ), <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> m<span style=color:#f92672>*</span>m ;
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> m<span style=color:#f92672>*</span>m ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Gradients:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//  41 pts uniformly over a line, mapped onto a diamond</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//  The ring size 17*17 = 289 is close to a multiple</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//      of 41 (41*7 = 287)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> fract(p <span style=color:#f92672>*</span> C.www) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> h <span style=color:#f92672>=</span> abs(x) <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> ox <span style=color:#f92672>=</span> floor(x <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> a0 <span style=color:#f92672>=</span> x <span style=color:#f92672>-</span> ox;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Normalise gradients implicitly by scaling m</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Approximation of: m *= inversesqrt(a0*a0 + h*h);</span>
</span></span><span style=display:flex><span>    m <span style=color:#f92672>*=</span> <span style=color:#ae81ff>1.79284291400159</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.85373472095314</span> <span style=color:#f92672>*</span> (a0<span style=color:#f92672>*</span>a0<span style=color:#f92672>+</span>h<span style=color:#f92672>*</span>h);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Compute final noise value at P</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> g <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>    g.x  <span style=color:#f92672>=</span> a0.x  <span style=color:#f92672>*</span> x0.x  <span style=color:#f92672>+</span> h.x  <span style=color:#f92672>*</span> x0.y;
</span></span><span style=display:flex><span>    g.yz <span style=color:#f92672>=</span> a0.yz <span style=color:#f92672>*</span> <span style=color:#66d9ef>vec2</span>(x1.x,x2.x) <span style=color:#f92672>+</span> h.yz <span style=color:#f92672>*</span> <span style=color:#66d9ef>vec2</span>(x1.y,x2.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>130.0</span> <span style=color:#f92672>*</span> dot(m, g);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> st <span style=color:#f92672>=</span> gl_FragCoord.xy<span style=color:#f92672>/</span>u_resolution.xy;
</span></span><span style=display:flex><span>    st.x <span style=color:#f92672>*=</span> u_resolution.x<span style=color:#f92672>/</span>u_resolution.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec3</span> color <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(<span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Scale the space in order to see the function</span>
</span></span><span style=display:flex><span>    st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>10.</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    color <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec3</span>(snoise(st)<span style=color:#f92672>*</span><span style=color:#ae81ff>.5</span><span style=color:#f92672>+</span><span style=color:#ae81ff>.5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(color,<span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-métodos><strong>3. Métodos</strong>
<a class=anchor href=#3-m%c3%a9todos>#</a></h3><p>Para llevar a cabo este ejercicio se llevó a cabo en primer lugar una revisión teórica de cada uno de los conceptos que envuelven la temática del proceso de procedural texturing. Para esto se jugo con la posiblidad de generar una textura de una pared de ladrillos desde el shader y darle algo de movimiento a este. Para realizar esto fue necesaria una investigación en cuanto a formas de generar imagenes de ruido para emular la rugocidad de los ladrillos, posteriormente, se implemetaron las diferentes opciones y se le añadio dinamismo al incluir como variable el tiempo, en forma del numero del frame actual, de esta forma se consigue que los ladrillos se empiecen a mover en la figura. Se tuvo la intención de añadir bump mapping para una comparación, pero el tiempo no nos permitio completarlo.</p><h3 id=4-resultados><strong>4. Resultados</strong>
<a class=anchor href=#4-resultados>#</a></h3><p>A partir del estudio llevado a cabo se realizó el siguiente programa con el fin de visualizar el efecto del procedural texturing.</p><details><summary>p5 - anti-aliasing code</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>{{<span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>p5</span><span style=color:#f92672>-</span><span style=color:#a6e22e>global</span><span style=color:#f92672>-</span><span style=color:#a6e22e>iframe</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;prod_text&#34;</span> <span style=color:#a6e22e>width</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;430&#34;</span> <span style=color:#a6e22e>height</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;430&#34;</span> <span style=color:#a6e22e>lib1</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/showcase/scripts/p5.treegl.js&#34;</span><span style=color:#f92672>&gt;</span>}}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>pg</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>truchetShader</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>preload</span>() {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// shader adapted from here: https://thebookofshaders.com/09/
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// truchetShader = readShader(&#39;brickwall.frag&#39;, { matrices: Tree.mvMatrix, varyings: Tree.texcoords2|Tree.normal3|Tree.position3});
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// console.log(parseVertexShader({ matrices: Tree.mvMatrix|Tree.pMatrix|Tree.pmvMatrix, varyings: Tree.texcoords2|Tree.normal3|Tree.position3}))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>truchetShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadShader</span>(<span style=color:#e6db74>&#39;/showcase/scripts/brickwall.vert&#39;</span>, <span style=color:#e6db74>&#39;/showcase/scripts/brickwall.frag&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// create frame buffer object to render the procedural texture
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraphics</span>(<span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>, <span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// use truchetShader to render onto pg
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>truchetShader</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// emitResolution, see:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// https://github.com/VisualComputing/p5.treegl#macros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>truchetShader</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// pg clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// set pg as texture
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>texture</span>(<span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>33</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>truchetShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;u_time&#39;</span>, <span style=color:#a6e22e>frameCount</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>orbitControl</span>();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// cylinder(100, 200);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>sphere</span>(<span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// cone(100,100);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// ambientLight(60);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// let locX = mouseX - width / 2;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// let locY = mouseY - height / 2;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// let light = treeLocation(createVector(-locX,-locY,1.5),{ from: &#39;SCREEN&#39;, to: &#39;WORLD&#39;});
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// pointLight(255, 255, 255, light.x, light.y, light.z);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// box(100);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mouseMoved</span>() {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// https://p5js.org/reference/#/p5.Shader/setUniform
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// pg.emitMousePosition(truchetShader);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>locX</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mouseX</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>locY</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mouseY</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>light</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>treeLocation</span>(<span style=color:#a6e22e>createVector</span>(<span style=color:#f92672>-</span><span style=color:#a6e22e>locX</span>,<span style=color:#f92672>-</span><span style=color:#a6e22e>locY</span>,<span style=color:#ae81ff>1.5</span>),{ <span style=color:#a6e22e>from</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;SCREEN&#39;</span>, <span style=color:#a6e22e>to</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;EYE&#39;</span>});
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>truchetShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;light_pos&#39;</span>,[<span style=color:#a6e22e>light</span>.<span style=color:#a6e22e>x</span>,<span style=color:#a6e22e>light</span>.<span style=color:#a6e22e>y</span>,<span style=color:#a6e22e>light</span>.<span style=color:#a6e22e>z</span>,<span style=color:#ae81ff>1.</span>] );
</span></span><span style=display:flex><span>      <span style=color:#75715e>// pg clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>{{<span style=color:#f92672>&lt;</span> <span style=color:#960050;background-color:#1e0010>/p5-global-iframe &gt;}}</span>
</span></span></code></pre></div></div></details><iframe id=prod_text style=width:430px;height:430px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=/showcase/scripts/p5.min.js></script>
            <script src=/showcase/scripts/p5.sound.min.js></script>
             <script src=/showcase/scripts/p5.treegl.js></script> 
            
            
            
            
            <script>
              
    let pg;
    let truchetShader;

    function preload() {
      // shader adapted from here: https://thebookofshaders.com/09/
      // truchetShader = readShader('brickwall.frag', { matrices: Tree.mvMatrix, varyings: Tree.texcoords2|Tree.normal3|Tree.position3});
      // console.log(parseVertexShader({ matrices: Tree.mvMatrix|Tree.pMatrix|Tree.pmvMatrix, varyings: Tree.texcoords2|Tree.normal3|Tree.position3}))
      truchetShader = loadShader('/showcase/scripts/brickwall.vert', '/showcase/scripts/brickwall.frag');
    }

    function setup() {
      createCanvas(400, 400, WEBGL);
      // create frame buffer object to render the procedural texture
      pg = createGraphics(400, 400, WEBGL);
      textureMode(NORMAL);
      noStroke();
      pg.noStroke();
      // use truchetShader to render onto pg
      pg.shader(truchetShader);
      // emitResolution, see:
      // https://github.com/VisualComputing/p5.treegl#macros
      pg.emitResolution(truchetShader);
      // pg clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1])
      pg.quad(-1, -1, 1, -1, 1, 1, -1, 1);
      // set pg as texture
      texture(pg);
    }

    function draw() {
      background(33);
      truchetShader.setUniform('u_time', frameCount);
      pg.quad(-1, -1, 1, -1, 1, 1, -1, 1);
      orbitControl();
      // cylinder(100, 200);
      sphere(100)
      // cone(100,100);

      // ambientLight(60);
      // let locX = mouseX - width / 2;
      // let locY = mouseY - height / 2;
      // let light = treeLocation(createVector(-locX,-locY,1.5),{ from: 'SCREEN', to: 'WORLD'});
      // pointLight(255, 255, 255, light.x, light.y, light.z);
      // box(100);
    }
    function mouseMoved() {
      // https://p5js.org/reference/#/p5.Shader/setUniform
      // pg.emitMousePosition(truchetShader);
      let locX = mouseX - width / 2;
      let locY = mouseY - height / 2;
      let light = treeLocation(createVector(-locX,-locY,1.5),{ from: 'SCREEN', to: 'EYE'});
      truchetShader.setUniform('light_pos',[light.x,light.y,light.z,1.] );
      // pg clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1])
      pg.quad(-1, -1, 1, -1, 1, 1, -1, 1);
    } 
    

            </script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h3 id=5-discusión><strong>5. Discusión</strong>
<a class=anchor href=#5-discusi%c3%b3n>#</a></h3><p>Partiendo de los resultados obtenidos tenemos que se puede evidenciar un <em>suavizado</em> en los bordes de cada triángulo generado dependiendo de qué fracción de los píxeles de los bordes estén por dentro y qué fracción estén por fuera. Por otra parte, y partiendo del hecho de que se realizó una subdivisión de cada píxel en 256 subpíxeles se evidencia que el proceso de rasterización que se lleva a cabo para determinar el promedio del color del píxel se hace de manera rápida debido a que el cálculo de las funciones de borde para cada subpíxel no significa una carga computacional grande.</p><h3 id=6-conclusión><strong>6. Conclusión</strong>
<a class=anchor href=#6-conclusi%c3%b3n>#</a></h3><ol><li>El anti-aliasing es un proceso de mucha utilidad y aplicabilidad por ejemplo en el contexto de los videojuegos ya que provee de un algorítmo eficiente con el cual dar un efecto de suavizado de las figuras y de esta manera el usuario puede tener una visualización de los gráficos mucho más agradable.</li></ol><p><img src=/showcase/sketches/anti-aliasing-effect-.jpg alt="Efecto del antialiasing." title="Efecto AA"></p><ol start=2><li></li></ol><h3 id=7-referencias><strong>7. Referencias</strong>
<a class=anchor href=#7-referencias>#</a></h3><ul><li><a href=https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-practical-implementation>Rasterization: a Practical Implementation</a></li><li><a href=https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/n>The barycentric conspiracy</a></li><li><a href=https://en.wikipedia.org/wiki/Spatial_anti-aliasing>Spatial anti-aliasing</a></li><li><a href="https://helpx.adobe.com/photoshop-elements/key-concepts/aliasing-anti-aliasing.html#:~:text=Anti-aliasing%20is%20the%20smoothing,make%20the%20edges%20appear%20smoother.">Aliasing & Anti-aliasing</a></li><li><a href=https://github.com/objetos/p5.quadrille.js/blob/main/examples/raster/sketch.js>Raster in p5.quadrille.js</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/eb724adb8b1f4540dd4b0b2dec20acf92525df32 title="Last modified by cristian vargas | June 27, 2022" target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 27, 2022</span></a></div></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#procedural-texturing><strong>Procedural texturing</strong></a><ul><li><ul><li><a href=#1-introducción><strong>1. Introducción</strong></a></li><li><a href=#2-revisión-bibliográfica><strong>2. Revisión bibliográfica</strong></a></li><li><a href=#3-métodos><strong>3. Métodos</strong></a></li><li><a href=#4-resultados><strong>4. Resultados</strong></a></li><li><a href=#5-discusión><strong>5. Discusión</strong></a></li><li><a href=#6-conclusión><strong>6. Conclusión</strong></a></li><li><a href=#7-referencias><strong>7. Referencias</strong></a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>